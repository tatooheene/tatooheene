---
title: "Discounting with tatooheene"
author: "The tatooheene team"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: false
vignette: >
  %\VignetteIndexEntry{Discounting with tatooheene}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, comment = "#>", fig.width = 7, fig.height = 4, dpi = 120
)
library(tatooheene)
```

## What this vignette covers

-   What **discounting** is.
-   How to call `apply_discounting()` and how to interpret the outputs.
-   How to make use of the accompanied case-example dataset `tatooheene::data_model_sick_sicker`

## Background

Costs and health outcomes that are expected to occur in the future are generally valued less than those that occur in the present, and so it is recommended that they be discounted in economic analyses. In the Netherlands, a discount rate of 1.5% for health effects and 3% for costs are used. Discounting is typically done by presenting the costs and health outcomes as a stream of values over time and applying a discounting factor based on the discount rate to each value, and then aggregating them to obtain the ‘present value’ of each stream. The discount factor is increasing over time, based on the underlying fixed discount rate.

*Text adapted from Dutch costing manual and Discount Rate [online]. (2016). York; York Health Economics Consortium; 2016. <https://yhec.co.uk/glossary/discount-rate/>.*

## Formulas

The most common method is to calculate a net present value based on constant discounting.

When taking costs as an example, the net present value of costs ($C$) from the current year ($t=0$) up to and including year $n$ under a constant discounting model is:

$$
C \;=\; \sum_{t=0}^{n} {K_t}{(1+i)^{-t}}
$$

where $K_t$ denotes the costs in year $t$ and $i$ is the constant discount rate. No discounting is applied at $t=0$.

Please note that the net present value for costs, $C$, could also be the net present value of an health effect, e.g. QALYs.

It is also worth noticing, that the formula as presented in the Dutch manual is a rewritten form from the often presented formula in this form:

$$
NPV \;=\; \frac{V}{(1+r)^{t}}
$$ where $NVP$ is the next present value, $V$ is the value, $r$ the discount rate and $t$ time.

## R example from the Dutch guideline

In an economic evaluation, annual costs for standard of care (SoC) are estimated to be €100.00. Without discounting, the total costs after 3 years are €300.00.

```{r no-discount}
c_annual <- 100
c_t3_undiscounted <- 3 * c_annual
c_t3_undiscounted
```

Based on the annual costs, we make a vector of these costs for the three years.

```{r discount-rate}
v_c_SoC <- rep(c_annual, 3) # Vector of costs values on all years for standard of care 
names(v_c_SoC) <- c("Year 1", "Year 2", "Year 3") # name the vector 
```

Next, we can discount this stream of costs using the function `apply_discounting` via the following code:

```{r example-guideline}
apply_discounting(values = v_c_SoC, discount_rate = "costs", times = c(0, 1, 2))
```
The function gives a vector of discounted values. As the default discount rate for costs in the Netherlands is 3%, this is the values as used by the function. 


### Present the values as aggreated or rounded values
You can sum these values using the basic `sum()` or using the argument `aggregate`. 

```{r example-guideline-sum}
# aggregate the values
sum(apply_discounting(values = v_c_SoC, discount_rate = "costs", times = c(0, 1, 2))) # sum 
apply_discounting(values = v_c_SoC, discount_rate = "costs", times = c(0, 1, 2), aggregate = TRUE) # aggregate TRUE

# rounding 
apply_discounting(values = v_c_SoC, discount_rate = "costs", times = c(0, 1, 2), digits = 3) # use 3 digits 
apply_discounting(values = v_c_SoC, discount_rate = "costs", times = c(0, 1, 2), aggregate = TRUE, digits = 2) # round to 2 decimals 
```


## R example for discounting on single value

If we like to only discount a one time costs of €150 euro at time year 4. We can use the function as follows:

```{r example-value}
apply_discounting(values = 150, discount_rate = "costs", times = 4)
```

The function now returns the net present values of 150 euro after 4 years time.

## R example for health effects

As discussed before, the same applies to health effects, in this example QALYs. In this example, an individual is expected to life a perfect life over a four year period and each year 1 QALY is accrued. We do not apply discounting in the first year.

```{r example-discount-stream-QALY}
apply_discounting(value = c(1, 1, 1, 1), discount_rate = "effects", times = c(0, 1, 2, 3))
```

# Discounting the first cycle and set up the vector for time

As you might have noticed, the first cycle is not discounted. This is in line with the Dutch guidelines that recommend not to discount the first cycle. Therefore, the vector for times start with a zero. A generic example of how to set up the vector for time is shown below

```{r example-set-up-times-vector}
v_times             <- seq(from = 0, to = length(v_c_SoC) - 1, by = 1 )
```

However, in some circumstances the first year has to be discounted. In that case, vector for times has to start at 1. This can be done with the code below.

```{r example-set-up-times-vector-discount-y1}
v_times_discount_y1 <- seq(from = 1, to = length(v_c_SoC), by = 1 ) 
# or 
v_times_discount_y1 <- seq_along(v_c_SoC)

```

# Discounting in models with sub-annual cycle lengths

While the application of discounting is straightforward in models with annual cycles, it becomes more ambiguous in models that use sub-annual time steps (e.g., monthly or weekly cycles). The Dutch guideline does not specify how to handle the timing of discounting in such cases, leaving room for interpretation within the modeling community.

Different approaches have emerged: some modelers apply discounting starting after the first sub-annual cycle (e.g., excluding only the first month from discounting), as they link this to the fact that discounting relate to the fundamental principle that costs and benefits should be discounted beyond the present, and interpret every time point after the first cycle (present) as future. Others assume that no discounting occurs during the first full year, after which discounting is applied at intervals corresponding to the model’s cycle length. This lack of explicit guidance can lead to variation in results and underlines the importance of transparently reporting how discounting is implemented in sub-annual models.

## Why does this matter?
Although yearly and monthly discounting approaches produce the same total undiscounted QALYs or costs, they differ in discounted values due to when outcomes are assumed to occur. In annual models, outcomes are often assumed to occur at the end of the yearly cycle, while in sub-annual models the rewards are typically accrued more evenly across time as they are awarded at the end of each monthly cycle. This leads to slightly higher present values in the sub-annual models, as benefits (or costs) occur earlier in time, and are therefore less discounted.

In the example below we demonstrate this concept using a hypothetical situation in which 1 QALY is awarded in a period of 4 years, the annual model. This gives a total of 4 undiscounted QALYs and 3.854385 discounted QALYs. Next, we demonstrate a model with monthly cycles, in which 1/12th QALY is awarded each cycle. This results in a total of 4 undiscounted QALYS, similar to the annual model. However, the discounted QALYs are 3.8808, which are 0.026427 QALYs more compared to the annual model.

```{r demo-difference}
# Example of an annual model
values <- c(1, 1, 1, 1)            # 1 QALY per year
sum(values) # total undiscounted QALYs
v_times_year <- seq_along(values) # Time: 1, 2, 3, 4
v_QALY_discounted <- apply_discounting(values = values, discount_rate = "effects", times = v_times_year)
sum(v_QALY_discounted)            # ~3.854385

# Example of a model with monthly cycles 
values_month <-  rep(1/12, 4/(1/12)) # 1 QALY per year
sum(values_month) # total undiscounted QALYs
v_times_month <- seq_along(values_month) * 1/12 # Time: 1/12, 2/12, 3/12, etc.until time is 4
v_QALY_month_discounted <- apply_discounting(values = values_month, discount_rate = "effects", times = v_times_month)
sum(v_QALY_month_discounted)            # ~3.8808

```

## Our approach
Since the Dutch guidelines specifically state that the first year should not be discounted, this package does not discount the first year, while after this first year, discounting is applied using the cycle length of the model. However, this design choice has practical implications that might not be in line with the desired way of coding for all modelers and we therefore, demonstrate how to adjust the code in case other modelling assumptions are desired.


# Example using the Sick-Sicker model

For demonstration purposes we will make use of the Sick-Sicker example. In the code below we show applying discounting to the annual model.

## Sick-Sicker with annual cycles
```{r exmple-sick-sicker-annual}
data("data_model_output_sick_sicker") # Load the data 

# Use the annual model
l_m_M_annual[["Standard of care"]]

# Apply the utilities
v_Q_SoC <- l_m_M_annual[["Standard of care"]] %*% l_u_annual[["Standard of care"]]
n_undiscounted_Q_SoC <- sum(v_Q_SoC) # get the undiscounted QALYs
n_undiscounted_Q_SoC

# Apply discounting without discounting in the first year
v_times_annual <- seq(from = 0, to = length(v_Q_SoC) - 1, by = 1 )  
v_QALY_dis_Sick_Sicker_annual <- apply_discounting(values = v_Q_SoC, discount_rate = "effects", times = v_times_annual) # This gives the discounted QALYs
n_discounted_Q_SoC <- sum(v_QALY_dis_Sick_Sicker_annual)
n_discounted_Q_SoC

```

## Sick-Sicker with montly cycles
Below we focus on the model results for simulating the model using monthly cycles.
```{r exmple-sick-sicker-monthly}

# Use the annual model
head(l_m_M_monthly[["Standard of care"]])
tail(l_m_M_monthly[["Standard of care"]]) 
# here you see this file has more cycles compared to the annual model

# Apply the utilities for the montly cycles 
v_Q_SoC_monthly <- l_m_M_monthly[["Standard of care"]] %*% l_u_monthly[["Standard of care"]]
n_undiscounted_Q_SoC_monthly <- sum(v_Q_SoC_monthly) # get the undiscounted QALYs
n_undiscounted_Q_SoC_monthly
```

Please note, that the total undiscounted values between the monthly and yearly Sick-Sicker model differ a bit. This has to due with the timing of events during the simulation.

In the code example below we show how to discount the results for the monthly simulated model results without discounting in the first year, by applying a step-wise discounting after the first year. This means that we set the vector for time using

```{r example-sick-sicker-monhtly-discount-small-steps}
# Apply discounting without discounting in the first year 
cycle_length   <- 1/12 # cycle length in fraction of a year
v_times_monthly <- seq(from = 0, to = length(v_Q_SoC) - 1, by = cycle_length ) 

v_times_monthly[1:((1/cycle_length))] <- 0 
v_times_monthly[1:20] # print first twenty items to show times vector

v_QALY_dis_Sick_Sicker_monthly <- apply_discounting(values = v_Q_SoC_monthly, discount_rate = "effects", times = v_times_monthly) # This gives the discounted QALYs
n_discounted_Q_SoC_monthly <- round(sum(v_QALY_dis_Sick_Sicker_monthly), 3)
n_discounted_Q_SoC_monthly

```

## Sick-Sicker simulatied using montly cycles but discounted on a yearly scale
Alternatively, one could sum the markov trace `l_M` in periods of a yearly cycle and assume that all rewards happen at the end of the cycle. After this summation, discounting with yearly step can be applied.

\#@stijn, after we agree that we like to show this we can simpilfy and improve this code section \*\* Ik ben het hier mee eens, misschien even samen nog naar kijken hoe we dit het beste hier neer kunnen zetten. Wellicht kunnen we er subhoofdstukken van maken zodat het duidelijker wordt. Dus dat je een hoofdstuk hebt waar je de objecten maakt en dan de alternatieve manieren hoe je het kan aanpakken -> Ik heb nu sub-kopjes gemaakt. Maar ik denk dat jij bedoelt => data lade, tijd versies maken en daarna discounting wil laten zien? Dat kan dan misschien dinsdag gedaan worden. 
```{r}
# Add a year column based on cycle number
v_years         <- floor((seq_len(nrow(l_m_M_monthly$`Standard of care`)) - 1) / 12) 
m_M_SoC_monthly <- cbind(l_m_M_monthly$`Standard of care`, year = v_years)


sum(apply_discounting(values = v_Q_SoC_monthly, discount_rate = "effect", times = v_years))

# Aggregate by year
m_M_annual_aggrated_from_month_init <- m_M_SoC_monthly[1, ]
m_M_annual_aggrated_from_month <- as.matrix(aggregate(m_M_SoC_monthly[-1, c("H", "S1", "S2", "D")]/12,
                           by = list(m_M_SoC_monthly[-1, c("year")]),
                           FUN = sum))

m_M_annual_aggrated_from_month <- rbind(m_M_annual_aggrated_from_month_init[c("H", "S1", "S2", "D")],
                                        m_M_annual_aggrated_from_month[, c("H", "S1", "S2", "D")] )


# View the result
print(m_M_annual_aggrated_from_month)

# Apply costs
v_c_sick_sicker_annual_aggrated_from_month <-  (m_M_annual_aggrated_from_month[, c("H", "S1", "S2", "D")] %*% l_u_annual[["Standard of care"]])


v_times <- seq(from = 0, to = length(v_c_sick_sicker_annual_aggrated_from_month) - 1, by = 1)
n_discounted_Q_SoC_monthly_annual_discount <- sum(apply_discounting(values = v_c_sick_sicker_annual_aggrated_from_month, discount_rate = "effect", times = v_times))
n_discounted_Q_SoC_monthly_annual_discount

```

Alternatively, you could use the vector with indicator for the year as the `times` vector and apply the discounting this way. This gives the same approach compared to

```{r}
v_c_sick_sicker_month <- m_M_SoC_monthly[, c("H", "S1", "S2", "D")] %*% l_u_monthly[["Standard of care"]]
v_c_sick_sicker_month <- sum(apply_discounting(values = v_c_sick_sicker_month, discount_rate = "effect", times = v_years ))
```

# Table with overview of the resuls
The overview below shows the undiscounted and discounted values of the different assumptions regarding time. 

#@EK: something seems weird as the annual discounted is higher compared to monthly, has to do with the timing of "cycles
```{r overview-discounted-values}
# Define the data
approaches          <- c("Annual-cycles and discounting", "Monthly cycles and discounting", "Monthly cycles, discounted annual")
undiscounted_values <- round(c(n_undiscounted_Q_SoC, n_undiscounted_Q_SoC_monthly, n_undiscounted_Q_SoC_monthly),3)
discounted_values   <- round(c(n_discounted_Q_SoC,   n_discounted_Q_SoC_monthly,   n_discounted_Q_SoC_monthly_annual_discount), 3)


# Create a data frame
results_table <- data.frame(
  Approach = approaches,
  Undiscounted_Value = undiscounted_values,
  Discounted_Value = discounted_values
)

# Print the table
print(results_table)

```



\#@stijn, willen we een overzicht van de verschillende getallen? Ik gebruik nu zowel effecten als kosten door elkaar. Willen we dat consitent hetzelfde? --> Misschien kunnen we per subhoofdstuk zoals hierboven beschreven de resultaten geven zodat ze ook weten dat de betreffende resultaten bij een bepaalde subparagraaf horen. 

## Input validation & common messages

# @Stijn what do add here? Hier kunnen we nog toevoegen dat gebruikers een keuze moeten maken tussen wat voor rate ze willen voor discount (op dit moment tussen effects and costs), dat de vector van tijd van gelijke lengte moet zijn als de vector van de kosten, utilities nooit groter kunnen zijn dan 1 en kosten nooit lager dan 0 in de input. 

## Error messages you might see 

-   **"`values` must be numeric"**\
    The values argument needs to get a numeric value (scalar) or vector of numeric values (vector)
-   **"`discount_rate` must be numeric"**\
-   **"`discount_rate` must be between 0 and 1")**\

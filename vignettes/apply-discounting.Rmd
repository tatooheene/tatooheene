---
title: "Discounting with tatooheene"
author: "The tatooheene team"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    number_sections: false
vignette: >
  %\VignetteIndexEntry{Discounting with tatooheene}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE, comment = "#>", fig.width = 7, fig.height = 4, dpi = 120
)
library(tatooheene)
```

## What this vignette covers

-   What **discounting** is.
-   How to call `apply_discounting()` and how to interpret the outputs.
-   How to make use of the accompanied case-example dataset `tatooheene::data_model_sick_sicker`

## Background

Costs and health outcomes that are expected to occur in the future are generally valued less than those that occur in the present, and so it is recommended that they be discounted in economic analyses. In the Netherlands, a discount rate of 1.5% for health effects and 3% for costs are used. Discounting is typically done by presenting the costs and health outcomes as a stream of values over time and applying a discounting factor based on the discount rate to each value, and then aggregating them to obtain the 'present value' of each stream. The discount factor is increasing over time, based on the underlying fixed discount rate.

*Text adapted from Dutch costing manual and Discount Rate [online]. (2016). York; York Health Economics Consortium; 2016. <https://yhec.co.uk/glossary/discount-rate/>.*

## Formulas

The most common method is to calculate a net present value based on constant discounting.

When taking costs as an example, the net present value of costs ($C$) from the current year ($t=0$) up to and including year $n$ under a constant discounting model is:

$$
C \;=\; \sum_{t=0}^{n} {K_t}{(1+i)^{-t}}
$$

where $K_t$ denotes the costs in year $t$ and $i$ is the constant discount rate. No discounting is applied at $t=0$.

Please note that the net present value for costs, $C$, could also be the net present value of an health effect, e.g. QALYs.

It is also worth noticing, that the formula as presented in the Dutch manual is a rewritten form from the often presented formula in this form:

$$
NPV \;=\; \frac{V}{(1+r)^{t}}
$$
where $NVP$ is the next present value, $V$ is the value, $r$ the discount rate and $t$ time.

## R example from the Dutch guideline

In an economic evaluation, annual costs for standard of care (SoC) are estimated to be €100.00. Without discounting, the total costs after 3 years are €300.00.

```{r no-discount}
c_annual <- 100
c_t3_undiscounted <- 3 * c_annual
c_t3_undiscounted
```

Based on the annual costs, we make a vector of these costs for the three years.

```{r discount-rate}
v_c_SoC <- rep(c_annual, 3) # Vector of costs values on all years for standard of care 
names(v_c_SoC) <- c("Year 1", "Year 2", "Year 3") # name the vector 
```

Next, we can discount this stream of costs using the function `tatooheene::apply_discounting()` via the following code:

```{r example-guideline}
apply_discounting(values = v_c_SoC, discount_rate = "costs", times = c(0, 1, 2))
```

The function gives a vector of discounted values. As the default discount rate for costs in the Netherlands is 3%, this is the values as used by the function. 

### Present the values as aggregated or rounded values

You can sum these values using the Base R `sum()` function or using the argument `aggregate`. 

```{r example-guideline-sum}
# aggregate the values
sum(apply_discounting(values = v_c_SoC, discount_rate = "costs", times = c(0, 1, 2))) # sum 
apply_discounting(values = v_c_SoC, discount_rate = "costs", times = c(0, 1, 2), aggregate = TRUE) # aggregate TRUE


# rounding 
apply_discounting(values = v_c_SoC, discount_rate = "costs", times = c(0, 1, 2), digits = 3) # use 3 digits 
apply_discounting(values = v_c_SoC, discount_rate = "costs", times = c(0, 1, 2), aggregate = TRUE, digits = 2) # round to 2 decimals 
```

## R example for discounting on single value

If we like to only discount a one time costs of €150 euro at time year 4. We can use the function as follows:

```{r example-value}

c_PV_150 <- apply_discounting(values = 150, discount_rate = "costs", times = 4)

cat("Present Value of", 150, " Euro in", 4, "years at", 3, "% =", round(c_PV_150, 2), "\n")
```

The function now returns the net present values of 150 euro after 4 years time.

## R example for health effects

The same applies to health effects, in this example QALYs. Here, an individual is expected to life a perfect life over a four year period and each year 1 QALY is accrued. We do not apply discounting in the first year.

```{r example-discount-stream-QALY}
apply_discounting(value = c(1, 1, 1, 1), discount_rate = "effects", times = c(0, 1, 2, 3))
```

## Understanding time assumptions in discounting

Discounting depends on when outcomes are assumed to occur within each model cycle. The Dutch guideline recommends *not discounting the first cycle*, which implies a specific assumption about timing. The examples below illustrate how to set up the `times` vector based on different timing assumptions.

### Outcomes at the start of each cycle

When outcomes are placed at the **start** of each cycle, the first year is not discounted. Time points start at 0 (e.g., 0, 1, 2, 3 …).

```{r example-set-up-times-vector}
v_times <- seq(from = 0, to = length(v_c_SoC) - 1, by = 1)
```

### Outcomes at the end of each cycle

When outcomes are assumed to occur at the **end** of each cycle, discounting starts immediately. In this case, the `times` vector should start at 1 (e.g., 1, 2, 3 …).

```{r example-set-up-times-vector-discount-y1}

v_times_discount_y1 <- seq(from = 1, to = length(v_c_SoC), by = 1) 
# or 
v_times_discount_y1 <- seq_along(v_c_SoC)
```

### Outcomes halfway through each cycle
A half-cycle correction assumes outcomes occur halfway through each cycle which could be a practical compromise between start- and end-of-cycle conventions.

```{r example-set-up-times-vector-half-cycle}
v_times_half_cycle <- seq(from = 0.5, to = length(v_c_SoC) - 0.5, by = 1)
```

## Discounting in models with sub-annual cycle lengths

While the application of discounting is straightforward in models with annual cycles, it becomes more ambiguous in models that use sub-annual time steps (e.g., monthly or weekly cycles). The Dutch guideline does not specify how to handle the timing of discounting in such cases, leaving room for interpretation within the modeling community.

Different approaches have emerged: some modelers apply discounting starting after the first sub-annual cycle (e.g., excluding only the first month from discounting), as they link this to the fact that discounting relate to the fundamental principle that costs and benefits should be discounted beyond the present, and interpret every time point after the first cycle (present) as future. Others assume that no discounting occurs during the first full year, after which discounting is applied at intervals corresponding to the model’s cycle length. This lack of explicit guidance can lead to variation in results and underlines the importance of transparently reporting how discounting is implemented in sub-annual models.

### Why does this matter? Why does timing affects the present value?
Although yearly and monthly discounting approaches produce the same total undiscounted QALYs or costs, they differ in discounted values due to when outcomes are assumed to occur. Events that occur earlier are discounted less and therefore have a higher present value. So if we switch from annual to monthly cycles, we simulate that instead of receiving one full QALY at the end of each year, we receive 1/12 of a QALY each month. And because the QALYs in a sub-annual model, the rewards happen slightly earlier in time, they lose a little less by discounting. Therefore, under the assumption that rewards occur at the *end of each period* (meaning discounting from the start), the monthly model gives slightly higher present values. This can be seen in the example below: 

#### Example without discounting in the first year 
Below, demonstrate this concept using a hypothetical situation in which 1 QALY is awarded in a period of 4 years, the annual model. This gives a total of 4 undiscounted QALYs and 3.854385 discounted QALYs. Next, we demonstrate a model with monthly cycles, in which 1/12th QALY is awarded each cycle. This results in a total of 4 undiscounted QALYS, similar to the annual model. However, the discounted QALYs are 3.8808, which are 0.026427 QALYs more compared to the annual model.

```{r demo-difference}
# Annual model WITH discounting the first year 
v_QALY <- rep(1, 4)       # 1 QALY per year
sum(v_QALY) # total undiscounted QALYs = 4
v_times_year <- seq_along(v_QALY) # Time: 1, 2, 3, 4
v_QALY_discounted <- apply_discounting(values = v_QALY, discount_rate = "effects", times = v_times_year)
pv_year_end <- sum(v_QALY_discounted)            # ~3.854385 WITH discounting first year 
pv_year_end 

# Monthly cycles WITH discounting the first year 
v_QALYs_monthly <-  rep(1/12, 4/(1/12)) # 1 QALY per year
sum(v_QALYs_monthly) # total undiscounted QALYs = 4 
v_times_month <- seq_along(v_QALYs_monthly) * 1/12 # Time: 1/12, 2/12, 3/12, etc.until time is 4
v_QALY_month_discounted <- apply_discounting(values = v_QALYs_monthly, discount_rate = "effects", times = v_times_month)
pv_month_end <- sum(v_QALY_month_discounted)        # ~3.8808 WITH discounting first year 
pv_month_end
```

### A counter intuative change 
When we assume that reward occur *at the start* of each period, the first QALY occurs immediately at time = 0, and we begin discounting only form the second year onwards This results in a shirt from the time horizon. With the annual model, the time ranges from year 0 to year 3, meaning the last event occurs at year 3. While in a monthly model, the time ranges from 0 to year 4, meaning that the last event occurs at year 4. 

So although in the monthly model, rewards occur earlier in time, they also extend one year further into the future. And this extra year of later events, offsets the early advantages, and results in a slight lower present value compared to the annual model. This is demonstrated in the example below: 

```{r demo-difference-without-discounting-first-year}
# Annual model withOUT discounting the first year 
v_times_year      <- seq(from = 0, to = length(v_QALY) - 1, by = 1 ) # -1 because we start at zero
v_QALY_discounted <- apply_discounting(values = v_QALY, discount_rate = "effects", times = v_times_year)
pv_year_start <- sum(v_QALY_discounted)            # ~3.9122 withOUT discounting first year 
pv_year_start

# Monthly cycles withOUT discounting the first year 
v_times_month <- seq(from = 0, to = length(v_QALYs_monthly)/12- 1 , by = 1/12) # Time: 1/12, 2/12, 3/12, etc.until time is 4 
# -1 because we start at zero
v_times_month[1:12] <- 0

v_QALY_month_discounted <- apply_discounting(values = v_QALYs_monthly, discount_rate = "effects", times = v_times_month)
pv_month_start <- sum(v_QALY_month_discounted)      # ~3.892422 withOUT discounting first year 
pv_month_start
```



```{r}
# Collect results
df_compare <- data.frame(
  Model = rep(c("Annual", "Monthly"), times = 2),
  Timing_assumption   = rep(c("End-of-cycle (discount from start)", "Start-of-cycle (no discount in 1st yar"), each = 2),
  When_last_QALY_happends = c("Year 4", "Year 4", "Year 3", "Year 4") ,
  PV = round(c(pv_year_end, pv_month_end, pv_year_start, pv_month_start),3)
)

print(df_compare)

```


```{r}

# Optional plot
library(ggplot2)

ggplot(df_compare, aes(x = Timing_assumption, y = PV, fill = Model)) +
  geom_bar(stat = "identity", position = position_dodge(width = 0.7)) +
  labs(
    title = "Comparison of Discounted QALYs by Timing Convention",
    y = "Total discounted QALYs (Present Value)",
    x = "Timing convention"
  ) +
  theme_minimal() +
  scale_fill_manual(values = c("Annual" = "steelblue", "Monthly" = "seagreen"))

```


## What to remember from timing in discounting? 
When discounting begins immediately, shorter cycles (monthly) give slightly higher PVs.
When the first period is undiscounted, shorter cycles extend the horizon and yield slightly lower PVs.


```{r image-to-examplain-timing, eval = TRUE, echo = FALSE}
# Improved timeline plot for vignette
# Paste this in an Rmd vignette or run in RStudio

# PARAMETERS
years <- 4
months_per_year <- 12
n_months <- years * months_per_year  # 48

# Create event times
annual_end   <- data.frame(facet = "Annual - End-of-cycle", t = 1:years)
monthly_end  <- data.frame(facet = "Monthly - End-of-cycle", t = seq(1/12, years, by = 1/12)) # length 48
annual_start <- data.frame(facet = "Annual - Start-of-cycle", t = 0:(years - 1))
monthly_start <- data.frame(facet = "Monthly - Start-of-cycle", t = seq(0, by = 1/12, length.out = n_months)) # 0, 1/12,...,47/12

# Combine
df_all <- bind_rows(annual_end, monthly_end, annual_start, monthly_start)

# Ensure factor order for neat vertical alignment
df_all$facet <- factor(df_all$facet, levels = c(
  "Annual - End-of-cycle",
  "Monthly - End-of-cycle",
  "Annual - Start-of-cycle",
  "Monthly - Start-of-cycle"
))

# Summary annotation for first and last events
ann <- df_all %>%
  group_by(facet) %>%
  summarise(t_first = min(t), t_last = max(t), n_points = n()) %>%
  ungroup()

# Plot
p <- ggplot(df_all, aes(x = t, y = facet)) +
  geom_segment(aes(x = 0, xend = years, y = facet, yend = facet),
               size = 0.35, linetype = "11", color = "grey60") +
  geom_point(size = 1.5, alpha = 0.9) +
  facet_wrap(~ facet, ncol = 1, scales = "free_y") +
  scale_x_continuous(breaks = seq(0, years, 1), limits = c(0, years)) +
  labs(
    title = "Event timing: Annual vs Monthly (Start vs End-of-cycle)",
    x = "Time (years)",
    y = "",
    subtitle = "Dots = when each QALY (or event) is accrued within a 4-year horizon"
  ) +
  theme_minimal() +
  theme(
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    strip.text = element_text(face = "bold"),
    plot.title = element_text(size = 13, face = "bold"),
    plot.subtitle = element_text(size = 10)
  ) +
  geom_vline(xintercept = c(years - 1, years), linetype = "dashed", size = 0.3, color = "grey70") # lines at 3 and 4

# Add annotation labels: first, last and number of dots
p <- p +
  geom_text(
    data = ann,
    aes(x = t_first, y = facet, label = paste0("first: ", round(t_first, 2))),
    vjust = -1.2, size = 3
  ) +
  geom_text(
    data = ann,
    aes(x = t_last, y = facet, label = paste0("last: ", round(t_last, 2))),
    vjust = -1.2, size = 3
  ) +
  geom_text(
    data = ann,
    aes(x = 0.2, y = facet, label = paste0("n = ", n_points)),
    hjust = 0, vjust = 2.2, size = 3.2
  )

# Print plot
print(p)


```


## What to remember from timing in discounting for the Dutch guidelines? 
Since the Dutch guidelines specifically state that the first year should not be discounted, the assumption should be made that rewards occur at the beginning of the cycle.
In order to NOT discount the first year, the `times` parameters should start with a zero in year 0 or needs to be zero of all months in the first year. 
In general, the differences in results are small, and will not have a consequence for the final decision. However, reporting the assumption help to interpet the reported discounted value.
And in most models, cycle-correction is applied any way, which gives a balanced approximation between both assumptions. 


## Example using the Sick-Sicker model

For demonstration purposes we will make use of the Sick-Sicker example. In the code below we show applying discounting to the annual model.

### Sick-Sicker with annual cycles
```{r exmple-sick-sicker-annual}
data("data_model_output_sick_sicker") # Load the data 

# Use the annual model
l_m_M_annual[["Standard of care"]]

# Apply the utilities
v_Q_SoC <- l_m_M_annual[["Standard of care"]] %*% l_u_annual[["Standard of care"]]
n_undiscounted_Q_SoC <- sum(v_Q_SoC) # get the undiscounted QALYs
n_undiscounted_Q_SoC

# Apply discounting without discounting in the first year
v_times_annual <- seq(from = 0, to = length(v_Q_SoC) - 1, by = 1 )  
v_QALY_dis_Sick_Sicker_annual <- apply_discounting(values = v_Q_SoC, discount_rate = "effects", times = v_times_annual) # This gives the discounted QALYs
n_discounted_Q_SoC <- sum(v_QALY_dis_Sick_Sicker_annual)
n_discounted_Q_SoC

```

### Sick-Sicker with monthly cycles
Below we focus on the model results for simulating the model using monthly cycles.
```{r exmple-sick-sicker-monthly}
# Use the annual model
head(l_m_M_monthly[["Standard of care"]])
tail(l_m_M_monthly[["Standard of care"]]) 
# here you see this file has more cycles compared to the annual model

# Apply the utilities for the montly cycles 
v_Q_SoC_monthly <- l_m_M_monthly[["Standard of care"]] %*% l_u_monthly[["Standard of care"]]
n_undiscounted_Q_SoC_monthly <- sum(v_Q_SoC_monthly) # get the undiscounted QALYs
n_undiscounted_Q_SoC_monthly
```

Please note, that the total undiscounted values between the monthly and yearly Sick-Sicker model differ a bit. This has to due with the timing of events during the simulation.

In the code example below we show how to discount the results for the monthly simulated model results without discounting in the first year, by applying a step-wise discounting after the first year. This means that we set the vector for time using

```{r example-sick-sicker-monhtly-discount-small-steps}
# Apply discounting without discounting in the first year 
cycle_length    <- 1/12 # cycle length in fraction of a year
v_times_monthly <- seq(from = 0, to = length(v_Q_SoC) - 1, by = cycle_length) 

v_times_monthly[1:((1/cycle_length))] <- 0 
v_times_monthly[1:20] # print first twenty items to show times vector

v_QALY_dis_Sick_Sicker_monthly <- apply_discounting(values = v_Q_SoC_monthly, discount_rate = "effects", times = v_times_monthly) # This gives the discounted QALYs
n_discounted_Q_SoC_monthly <- round(sum(v_QALY_dis_Sick_Sicker_monthly), 3)
n_discounted_Q_SoC_monthly

```

### Sick-Sicker simulatied using monthly cycles but discounted on a yearly scale
Alternatively, one could sum the markov trace `l_M` in periods of a yearly cycle and assume that all rewards happen at the end of the cycle. After this summation, discounting with yearly step can be applied.

\#@stijn, after we agree that we like to show this we can simpilfy and improve this code section \*\* Ik ben het hier mee eens, misschien even samen nog naar kijken hoe we dit het beste hier neer kunnen zetten. Wellicht kunnen we er subhoofdstukken van maken zodat het duidelijker wordt. Dus dat je een hoofdstuk hebt waar je de objecten maakt en dan de alternatieve manieren hoe je het kan aanpakken -> Ik heb nu sub-kopjes gemaakt. Maar ik denk dat jij bedoelt => data lade, tijd versies maken en daarna discounting wil laten zien? Dat kan dan misschien dinsdag gedaan worden. 
```{r}
# Add a year column based on cycle number
v_years         <- floor((seq_len(nrow(l_m_M_monthly$`Standard of care`)) - 1) / 12) 
m_M_SoC_monthly <- cbind(l_m_M_monthly$`Standard of care`, year = v_years)


##[STOP HERE - adjust rightS]
## apply first this rewards and sum than per year - after the discounting - otherwise not correctly done]
# tricky appraoch

sum(apply_discounting(values = v_Q_SoC_monthly, discount_rate = "effect", times = v_years))

# Aggregate by year
v_times_select_trace <- seq(1, length(v_Q_SoC_monthly), by = 12) # Identify the rows needed 

m_M_annual_aggrated_from_month <- m_M_SoC_monthly[v_times_select_trace, ]

# View the result
print(m_M_annual_aggrated_from_month)

# Apply costs
v_c_sick_sicker_annual_aggrated_from_month <-  (m_M_annual_aggrated_from_month[, c("H", "S1", "S2", "D")] %*% l_u_annual[["Standard of care"]])


v_times <- seq(from = 0, to = length(v_c_sick_sicker_annual_aggrated_from_month) - 1, by = 1)
n_discounted_Q_SoC_monthly_annual_discount <- sum(apply_discounting(values = v_c_sick_sicker_annual_aggrated_from_month, discount_rate = "effect", times = v_times))
n_discounted_Q_SoC_monthly_annual_discount

```

Alternatively, you could use the vector with indicator for the year as the `times` vector and apply the discounting this way. This gives the same approach compared to

```{r}
v_c_sick_sicker_month <- m_M_SoC_monthly[, c("H", "S1", "S2", "D")] %*% l_u_monthly[["Standard of care"]]
v_c_sick_sicker_month <- sum(apply_discounting(values = v_c_sick_sicker_month, discount_rate = "effect", times = v_years ))
```

### Table with overview of the resuls
The overview below shows the undiscounted and discounted values of the different assumptions regarding time. 
This is consistent with how we discussed the timing of event before. 

```{r overview-discounted-values}
# Define the data
approaches          <- c("Annual-cycles and discounting", "Monthly cycles and discounting", "Monthly cycles, discounted annual")
undiscounted_values <- round(c(n_undiscounted_Q_SoC, n_undiscounted_Q_SoC_monthly, n_undiscounted_Q_SoC_monthly),3)
discounted_values   <- round(c(n_discounted_Q_SoC,   n_discounted_Q_SoC_monthly,   n_discounted_Q_SoC_monthly_annual_discount), 3)


# Create a data frame
results_table <- data.frame(
  Approach = approaches,
  Undiscounted_Value = undiscounted_values,
  Discounted_Value = discounted_values
)

# Print the table
print(results_table)

```


## Error messages you might see 

-   **"`values` must be numeric"**\
    The values argument needs to get a numeric value (scalar) or vector of numeric values (vector)
-   **"`discount_rate` must be numeric"**\
-   **"`discount_rate` must be between 0 and 1")**\
